<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>GRS API documentation</title>
<meta name="description" content="Written by Zain Eris Kamal (zain.eris.kamal@rutgers.edu).
Full repository available here: https://github.com/Humboldt-Penguin/Mars-Magnetics-Research" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>GRS</code></h1>
</header>
<section id="section-intro">
<p>Written by Zain Eris Kamal (zain.eris.kamal@rutgers.edu).
Full repository available here: <a href="https://github.com/Humboldt-Penguin/Mars-Magnetics-Research">https://github.com/Humboldt-Penguin/Mars-Magnetics-Research</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Written by Zain Eris Kamal (zain.eris.kamal@rutgers.edu).
Full repository available here: https://github.com/Humboldt-Penguin/Mars-Magnetics-Research
&#34;&#34;&#34;


import matplotlib.pyplot as plt
import numpy as np

import os

# from lib.Utils import Utils as utils
# from lib.DataDownloader import DataDownloader as dd

import Utils as utils
import DataDownloader as dd

class GRS:
    &#34;&#34;&#34;
    A class that allows you to: 
        (1) Download GRS data, and 
        (2) Get elemental concetrations at exact coordinates by linearly interpolating between the four nearest points. 
            - Both exact concentration and volatile-adusted (normalized to an H20 and Si free basis) are available.
            
            
    Written by Zain Eris Kamal (zain.eris.kamal@rutgers.edu).
    Full repository available here: https://github.com/Humboldt-Penguin/Mars-Magnetics-Research
    &#34;&#34;&#34;
    
    
    
    
    
    nanval = -1e-10
    path__datahome = &#39;&#39;
    gdrive_url = r&#34;https://drive.google.com/drive/folders/17ukcBhiLvy4fVUT10YvSxf25Et2Ovgah?usp=sharing&#34;
    data = []
    
    
    
    
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        DESCRIPTION:
        ------------
            Initialize empty GRS object (no data yet).
        &#34;&#34;&#34;
        return
    
    
    
    
    
    
    def downloadData(self, path__datahome: str, overwrite: bool = False, verbose: bool = False) -&gt; None:
        &#34;&#34;&#34;
        DESCRIPTION:
        ------------
            Downloads and unzips data to `self.path__datahome` if it doesn&#39;t already exist there. If it already exists, overwrite if `overwrite==True`, else do nothing.
        
        PARAMETERS:
        ------------
            path : string
                Path from root to the directory within which the GRS data folder either (1) already exists, or (2) will be downloaded.
            overwrite : bool
                If true and data folder already exists, delete the data folder and download again. Else skip the download and inform the user. 
            verbose : bool
                If true, print contents of unzipped data folder. Else do nothing. 
        &#34;&#34;&#34;
        
        self.path__datahome = path__datahome
        dd.download_latest(path__datahome=self.path__datahome, data_name=&#39;GRS&#39;, url=self.gdrive_url, overwrite=overwrite, verbose=verbose)
        return
    
    
    
    
    
    
    def loadData(self) -&gt; None:
        &#34;&#34;&#34;
        DESCRIPTION:
        ------------
            Read GRS data from files into `self.data`. Format is a 2-dimensional array, where each entry a dictionary with keys for longitude, colongitude, latitude, colatitude, and concentrations for each of the seven elements.
            
            We use smoothed 5x5 data, but unsmoothed data is available at a higher resolution. Presumably this only requires changing the `path__datahome_data` variable, but this is not tested.
        &#34;&#34;&#34;
        
        
        path__datahome_data = utils.getPath(self.path__datahome, &#39;GRS&#39;, &#39;smoothed&#39;) # os.path.abspath(os.path.join(self.path, &#34;smoothed&#34;))
        
        self.data = []
              
        for datafilename in (os.listdir(path__datahome_data)):            
            if &#34;.tab&#34; in datafilename:
                # print(datafilename)

                # read file
                datafile = open(os.path.abspath(os.path.join(path__datahome_data, datafilename)), &#39;r&#39;)
                rawdata = datafile.readlines()
                datafile.close()

                # populate lon/lat values if first time
                if self.data == []: # populate lon/lat values
                    # loop setups
                    prevlat = None
                    thisline = []
                    for rawdataline in rawdata:
                        rawdataline = rawdataline.split()
                        thislat = float(rawdataline[0])
                        thisclon = float(rawdataline[1])
                        thiscola = utils.lat2cola(thislat)
                        thislon = utils.clon2lon(thisclon)
                        # thisconc = rawdataline[2]
                        if thislat != prevlat and prevlat != None:
                            self.data.append(thisline)
                            thisline = []
                        thisline.append({&#34;lon&#34;: thislon, &#34;lat&#34;: thislat, &#34;clon&#34;: thisclon, &#34;cola&#34;: thiscola})
                        prevlat = thislat
                    self.data.append(thisline)

                # populate data values                
                elementname = datafilename[:datafilename.index(&#34;_&#34;)]
                counter = 0
                for i in range(len(self.data)):
                    for j in range(len(self.data[0])):
                        # rawdataline = rawdataline.split()
                        thisconc = float(rawdata[counter].split()[2])
                        self.data[i][j][elementname] = thisconc if thisconc != 9999.999 else self.nanval
                        counter += 1
                        
        ## adjust longitude (realign to look like my qgis lol)
        lons = []
        for i in range(len(self.data[0])):
            lons.append(self.data[0][i][&#34;lon&#34;])
        # print(lons)
        for i in range(len(lons)):
            if lons[i] &lt; 0:
                break
        for k in range(len(self.data)):
            self.data[k] = self.data[k][i:] + self.data[k][:i]
        return
    
    
    # def fixUnits(self):
    #     # put wt% in terms of decimal proportions (1% -&gt; 0.01, ie 10e-2)
    #     # put ppm for Th to decimal proportions (1 ppm -&gt; 0.000001, ie 10e-6)
    #     for lat in range(len(self.data)):
    #         for lon in range(len(self.data[0])):
    #             for key in self.data[lat][lon]:
    #                 if key == &#34;th&#34;:
    #                     self.data[lat][lon][key] *= 10e-6
    #                 elif key != &#34;kvsth&#34;:
    #                     self.data[lat][lon][key] *= 10e-2
    #     return





    # def visualize(self, elementname):
    #     test = []
    #     for i in range(len(self.data)):
    #         newline = []
    #         for j in range(len(self.data[0])):
    #             val = self.data[i][j][elementname]
    #             newline.append(val if val &lt; 9000 else self.nanval)
    #             # print
    #         test.append(newline)
    #     plt.imshow(test[::-1], cmap=&#34;jet&#34;)
    #     plt.colorbar()
    #     return



    
    
    
    
    
    
    


    def visualize(self, elementname: str) -&gt; None:
        &#34;&#34;&#34;
        DESCRIPTION:
        ------------
            Plot the GRS global concentration map for a certain element. For reference, Olympus Mons is on the left.
            
        PARAMETERS:
        ------------
            elementname : str
                Element for which you want to make a global concentration map. Options are &#39;cl&#39;, &#39;fe&#39;, &#39;h2o&#39;, &#39;k&#39;, &#39;kvsth&#39;, &#39;si&#39;, and &#39;th&#39;.
        &#34;&#34;&#34;

        test = []
        for i in range(len(self.data)):
            newline = []
            for j in range(len(self.data[0])):
                val = self.data[i][j][elementname]
                newline.append(val if val &lt; 9000 else self.nanval)
                # print
            test.append(newline)
        
        fig, ax = plt.subplots(1,1,figsize=(7,5))
        im = ax.imshow(test[::-1], cmap=&#34;jet&#34;)
        # ax.invert_yaxis()
        cax = fig.add_axes([ax.get_position().x1+0.02,ax.get_position().y0,0.02,ax.get_position().height])
        plt.colorbar(im, cax=cax)
        plt.show()
        
        
        
        
        
        
        
        
        
        
        
    
    def getConcentration(self, lon: float, lat: float, elementname: str, normalized: bool = True) -&gt; float:
        &#34;&#34;&#34;
        DESCRIPTION:
        ------------
            Get the surface concentration of an element at the desired coordinate. Units in weight percent (Wt%) -- i.e. a 5% concentration would correspond to a return value of 0.05.
        
        PARAMETERS:
        ------------
            lon : float
                Longitude in range [-180, 180] (lon=0 cuts through Arabia Terra).
            lat : float
                Latitude in range [-90, 90].
            elementname : str
                Element for which you want to make a global concentration map. Options are &#39;cl&#39;, &#39;fe&#39;, &#39;h2o&#39;, &#39;k&#39;, &#39;kvsth&#39;, &#39;si&#39;, and &#39;th&#39;.
            normalized : bool 
                Determine whether or not to normalize to a volatile-free basis. See the next method &#34;getAdjustedConcentration&#34; for details.
            
        RETURN:
        ------------
            float
                Surface concentration of an element at the desired coordinate, using bilinear interpolation if that coordinate is not precisely defined by the data
                    - Units in weight percent (Wt%) -- i.e. a 5% concentration would correspond to a return value of 0.05.
                    - If atleast two of the nearest pixels are unresolved by GRS, just return the nanval.
        &#34;&#34;&#34;

        
        if normalized:
            return self.__getAdjustedConcentration(lon, lat, elementname)
        else:
            clon = utils.lon2clon(lon)
            cola = utils.lat2cola(lat)

            ## get lon/clon/lat/cola lists for easy searching
            
            lons = []
            for i in range(len(self.data[0])):
                lons.append(self.data[0][i][&#34;lon&#34;])
            # print(lons)
            clons = [utils.lon2clon(lon) for lon in lons]
            # print(clons)
            
            lats = []
            for i in range(len(self.data)):
                lats.append(self.data[i][0][&#34;lat&#34;])
            # print(lats)
            colas = [utils.lat2cola(lat) for lat in lats]
            # print(colas)

            ## get indexes and values for four nearest pixels

            if lon &lt;= lons[0] or lon &gt;= lons[-1]: # edge cases
                i_lon_left = len(lons)-1
                i_lon_right = 0
                lon_left = lons[i_lon_left]
                lon_right = lons[i_lon_right]
            else: # everything else
                for i in range(len(lons)):
                    if lon &lt; lons[i]:
                        i_lon_left = i-1
                        i_lon_right = i
                        lon_left = lons[i_lon_left]
                        lon_right = lons[i_lon_right]
                        break

            if lat &lt;= lats[0] or lat &gt;= lats[-1]: # edge cases
                i_lat_bottom = len(lats)-1
                i_lat_top = 0
                lat_bottom = lats[i_lat_bottom]
                lat_top = lats[i_lat_top]
            else: # everything else
                for i in range(len(lats)):
                    if lat &lt; lats[i]:
                        i_lat_bottom = i-1
                        i_lat_top = i
                        lat_bottom = lats[i_lat_bottom]
                        lat_top = lats[i_lat_top]
                        break


            top_left = self.data[i_lat_top][i_lon_left][elementname]
            top_right = self.data[i_lat_top][i_lon_right][elementname]
            bottom_left = self.data[i_lat_bottom][i_lon_left][elementname]
            bottom_right = self.data[i_lat_bottom][i_lon_right][elementname]
            
            
            ## IMPORTANT -- (handling locations where GRS data is undefined) if atleast two of the nearest pixels are unresolved by GRS, just return the nanval. 
            searchable = (top_left, top_right, bottom_left, bottom_right)
            if (searchable.count(self.nanval) &gt; 1):
                return self.nanval

            ## testing

            # print(f&#34;{lat_bottom} {utils.lon2clon(lon_left)} {bottom_left}&#34;)
            # print(f&#34;{lat_bottom} {utils.lon2clon(lon_right)} {bottom_right}&#34;)
            # print(f&#34;{lat_top} {utils.lon2clon(lon_left)} {top_left}&#34;)
            # print(f&#34;{lat_top} {utils.lon2clon(lon_right)} {top_right}&#34;)
            # print()
            # print(lon_left)
            # print(lon_right)
            # print(lat_bottom)
            # print(lat_top)

    #         ## dealing with negative/NaN values
    #         num_reals = 4
    #         avg = 0
    #         if top_left != -1:
    #             num_reals -= 1
    #             avg += top_left
    #         if top_right != -1:
    #             num_reals -= 1
    #             avg += top_right
    #         if bottom_left != -1:
    #             num_reals -= 1
    #             avg += bottom_left
    #         if bottom_right != -1:
    #             num_reals -= 1
    #             avg += bottom_right

    #         avg /= num_reals

            ## bilinear interpolation

            clon_left = utils.lon2clon(lon_left)
            clon_right = utils.lon2clon(lon_right)
            cola_bottom = utils.lat2cola(lat_bottom)
            cola_top = utils.lat2cola(lat_top)


            if abs(i_lon_right - i_lon_left) == 1: # somewhere in the middle
                londist = abs(lon_right-lon_left)
                leftdist = (lon-lon_left) / londist
                rightdist = (lon_right-lon) / londist
            else: # on the edges
                londist = abs(clon_right-clon_left)
                leftdist = (clon-clon_left) / londist
                rightdist = (clon_right-clon) / londist
            # print(londist)
            topinterp = top_left*(1-leftdist) + top_right*(1-rightdist)
            bottominterp = bottom_left*(1-leftdist) + bottom_right*(1-rightdist)


            if abs(i_lat_top - i_lat_bottom) == 1: # somewhere in the middle
                latdist = abs(lat_top-lat_bottom)
                bottomdist = (lat-lat_bottom) / latdist
                topdist = (lat_top-lat) / latdist
            else: # on the edges
                latdist = abs(cola_top-cola_bottom)
                bottomdist = (cola-cola_bottom) / latdist
                topdist = (cola_top-cola) / latdist    
            # print(latdist)

            finalinterp = topinterp*(1-topdist) + bottominterp*(1-bottomdist)

            if elementname == &#34;th&#34;:
                # finalinterp *= 1e-6
                finalinterp *= 10**-6
            else:
                # finalinterp *= 1e-2
                finalinterp *= 10**-2

            return finalinterp

            # return [londist, latdist]
        
        
        
        
        
        
        
    def __getAdjustedConcentration(self, lon: float, lat: float, elementname: str) -&gt; float:
        &#34;&#34;&#34;
        Helper method for &#34;getConcentration&#34; which returns an elemental concentration after normalizing out volatiles at that coordinate.
        
        &#34;Groundwater production from geothermal heating on early Mars and implication for early martian habitability&#34;
            Ojha et al. 2020
            https://www.science.org/doi/10.1126/sciadv.abb1669
            
        &gt; For such measurement to represent the bulk chemistry of the martian upper crust, it must be normalized to 
        &gt; a volatile-free basis (22). That equates to a 7 to 14% increase in the K, Th, and U abundances (22), which 
        &gt; we applied to the chemical maps by renormalizing to Cl, stoichiometric H2O, and S-free basis.
        &#34;&#34;&#34;
        
        init_conc = self.getConcentration(lon, lat, elementname, normalized=False)
        # if elementname == &#34;th&#34;:
        #     init_conc *= 10e-4
        
        sum_volatile_conc = 0
        for volatile in [&#34;cl&#34;, &#34;h2o&#34;, &#34;si&#34;]:
            this_conc = self.getConcentration(lon,lat, volatile, normalized=False)
            
            ## IMPORTANT -- handling locations where GRS data is undefined
            if this_conc == self.nanval:
                return self.nanval
            
            
            
            # print(this_conc)
            if this_conc &gt; 0:
                sum_volatile_conc += this_conc
        # print(sum_volatile_conc)
        # init_conc *= (1)/(1-(sum_volatile_conc/100))
        init_conc *= (1)/(1-(sum_volatile_conc))
        
        return init_conc
    
    
    
    
    
    
    
    
    def getNanVal(self) -&gt; float:
        &#34;&#34;&#34;
        Return value used for coordinates where GRS doesn&#39;t provide data.
        &#34;&#34;&#34;
        return self.nanval

    
    
    
    
    
    
    
###########################
# General helper functions


&#39;&#39;&#39;
These were moved to the Utils.py class

def lon2clon(lon: float) -&gt; float:
    &#34;&#34;&#34;
    Converts longitude value in range [-180,180] to cyclical longitude (aka colongitude) in range [180,360]U[0,180], in degrees.
    
    Using longitude [-180,180] puts Arabia Terra in the middle.
    Using cyclical longitude [0,360] puts Olympus Mons in the middle.
    
    &#34;&#34;&#34;
    return lon % 360


def clon2lon(clon: float) -&gt; float:
    &#34;&#34;&#34;
    Converts cyclical longitude (aka colongitude) in range [0,360] to longitude in range [0,180]U[-180,0].
    
    Using longitude [-180,180] puts Arabia Terra in the middle.
    Using cyclical longitude [0,360] puts Olympus Mons in the middle.
    &#34;&#34;&#34;
    return ((clon-180) % 360) - 180


def lat2cola(lat: float) -&gt; float:
    &#34;&#34;&#34;
    Converts latitude value in range [-90,90] to cyclical latitude (aka colatitude) in range [0,180], in degrees.    
    &#34;&#34;&#34;
    return lat % 180

def cola2lat(cola: float) -&gt; float:
    &#34;&#34;&#34;
    Converts cyclical latitude (aka colatitude) in range [0,180] to latitude value in range [-90,90], in degrees.    
    &#34;&#34;&#34;
    return ((cola-90) % 180) - 90
&#39;&#39;&#39;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="GRS.GRS"><code class="flex name class">
<span>class <span class="ident">GRS</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class that allows you to:
(1) Download GRS data, and
(2) Get elemental concetrations at exact coordinates by linearly interpolating between the four nearest points.
- Both exact concentration and volatile-adusted (normalized to an H20 and Si free basis) are available.</p>
<p>Written by Zain Eris Kamal (zain.eris.kamal@rutgers.edu).
Full repository available here: <a href="https://github.com/Humboldt-Penguin/Mars-Magnetics-Research">https://github.com/Humboldt-Penguin/Mars-Magnetics-Research</a></p>
<h2 id="description">DESCRIPTION:</h2>
<pre><code>Initialize empty GRS object (no data yet).
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GRS:
    &#34;&#34;&#34;
    A class that allows you to: 
        (1) Download GRS data, and 
        (2) Get elemental concetrations at exact coordinates by linearly interpolating between the four nearest points. 
            - Both exact concentration and volatile-adusted (normalized to an H20 and Si free basis) are available.
            
            
    Written by Zain Eris Kamal (zain.eris.kamal@rutgers.edu).
    Full repository available here: https://github.com/Humboldt-Penguin/Mars-Magnetics-Research
    &#34;&#34;&#34;
    
    
    
    
    
    nanval = -1e-10
    path__datahome = &#39;&#39;
    gdrive_url = r&#34;https://drive.google.com/drive/folders/17ukcBhiLvy4fVUT10YvSxf25Et2Ovgah?usp=sharing&#34;
    data = []
    
    
    
    
    def __init__(self) -&gt; None:
        &#34;&#34;&#34;
        DESCRIPTION:
        ------------
            Initialize empty GRS object (no data yet).
        &#34;&#34;&#34;
        return
    
    
    
    
    
    
    def downloadData(self, path__datahome: str, overwrite: bool = False, verbose: bool = False) -&gt; None:
        &#34;&#34;&#34;
        DESCRIPTION:
        ------------
            Downloads and unzips data to `self.path__datahome` if it doesn&#39;t already exist there. If it already exists, overwrite if `overwrite==True`, else do nothing.
        
        PARAMETERS:
        ------------
            path : string
                Path from root to the directory within which the GRS data folder either (1) already exists, or (2) will be downloaded.
            overwrite : bool
                If true and data folder already exists, delete the data folder and download again. Else skip the download and inform the user. 
            verbose : bool
                If true, print contents of unzipped data folder. Else do nothing. 
        &#34;&#34;&#34;
        
        self.path__datahome = path__datahome
        dd.download_latest(path__datahome=self.path__datahome, data_name=&#39;GRS&#39;, url=self.gdrive_url, overwrite=overwrite, verbose=verbose)
        return
    
    
    
    
    
    
    def loadData(self) -&gt; None:
        &#34;&#34;&#34;
        DESCRIPTION:
        ------------
            Read GRS data from files into `self.data`. Format is a 2-dimensional array, where each entry a dictionary with keys for longitude, colongitude, latitude, colatitude, and concentrations for each of the seven elements.
            
            We use smoothed 5x5 data, but unsmoothed data is available at a higher resolution. Presumably this only requires changing the `path__datahome_data` variable, but this is not tested.
        &#34;&#34;&#34;
        
        
        path__datahome_data = utils.getPath(self.path__datahome, &#39;GRS&#39;, &#39;smoothed&#39;) # os.path.abspath(os.path.join(self.path, &#34;smoothed&#34;))
        
        self.data = []
              
        for datafilename in (os.listdir(path__datahome_data)):            
            if &#34;.tab&#34; in datafilename:
                # print(datafilename)

                # read file
                datafile = open(os.path.abspath(os.path.join(path__datahome_data, datafilename)), &#39;r&#39;)
                rawdata = datafile.readlines()
                datafile.close()

                # populate lon/lat values if first time
                if self.data == []: # populate lon/lat values
                    # loop setups
                    prevlat = None
                    thisline = []
                    for rawdataline in rawdata:
                        rawdataline = rawdataline.split()
                        thislat = float(rawdataline[0])
                        thisclon = float(rawdataline[1])
                        thiscola = utils.lat2cola(thislat)
                        thislon = utils.clon2lon(thisclon)
                        # thisconc = rawdataline[2]
                        if thislat != prevlat and prevlat != None:
                            self.data.append(thisline)
                            thisline = []
                        thisline.append({&#34;lon&#34;: thislon, &#34;lat&#34;: thislat, &#34;clon&#34;: thisclon, &#34;cola&#34;: thiscola})
                        prevlat = thislat
                    self.data.append(thisline)

                # populate data values                
                elementname = datafilename[:datafilename.index(&#34;_&#34;)]
                counter = 0
                for i in range(len(self.data)):
                    for j in range(len(self.data[0])):
                        # rawdataline = rawdataline.split()
                        thisconc = float(rawdata[counter].split()[2])
                        self.data[i][j][elementname] = thisconc if thisconc != 9999.999 else self.nanval
                        counter += 1
                        
        ## adjust longitude (realign to look like my qgis lol)
        lons = []
        for i in range(len(self.data[0])):
            lons.append(self.data[0][i][&#34;lon&#34;])
        # print(lons)
        for i in range(len(lons)):
            if lons[i] &lt; 0:
                break
        for k in range(len(self.data)):
            self.data[k] = self.data[k][i:] + self.data[k][:i]
        return
    
    
    # def fixUnits(self):
    #     # put wt% in terms of decimal proportions (1% -&gt; 0.01, ie 10e-2)
    #     # put ppm for Th to decimal proportions (1 ppm -&gt; 0.000001, ie 10e-6)
    #     for lat in range(len(self.data)):
    #         for lon in range(len(self.data[0])):
    #             for key in self.data[lat][lon]:
    #                 if key == &#34;th&#34;:
    #                     self.data[lat][lon][key] *= 10e-6
    #                 elif key != &#34;kvsth&#34;:
    #                     self.data[lat][lon][key] *= 10e-2
    #     return





    # def visualize(self, elementname):
    #     test = []
    #     for i in range(len(self.data)):
    #         newline = []
    #         for j in range(len(self.data[0])):
    #             val = self.data[i][j][elementname]
    #             newline.append(val if val &lt; 9000 else self.nanval)
    #             # print
    #         test.append(newline)
    #     plt.imshow(test[::-1], cmap=&#34;jet&#34;)
    #     plt.colorbar()
    #     return



    
    
    
    
    
    
    


    def visualize(self, elementname: str) -&gt; None:
        &#34;&#34;&#34;
        DESCRIPTION:
        ------------
            Plot the GRS global concentration map for a certain element. For reference, Olympus Mons is on the left.
            
        PARAMETERS:
        ------------
            elementname : str
                Element for which you want to make a global concentration map. Options are &#39;cl&#39;, &#39;fe&#39;, &#39;h2o&#39;, &#39;k&#39;, &#39;kvsth&#39;, &#39;si&#39;, and &#39;th&#39;.
        &#34;&#34;&#34;

        test = []
        for i in range(len(self.data)):
            newline = []
            for j in range(len(self.data[0])):
                val = self.data[i][j][elementname]
                newline.append(val if val &lt; 9000 else self.nanval)
                # print
            test.append(newline)
        
        fig, ax = plt.subplots(1,1,figsize=(7,5))
        im = ax.imshow(test[::-1], cmap=&#34;jet&#34;)
        # ax.invert_yaxis()
        cax = fig.add_axes([ax.get_position().x1+0.02,ax.get_position().y0,0.02,ax.get_position().height])
        plt.colorbar(im, cax=cax)
        plt.show()
        
        
        
        
        
        
        
        
        
        
        
    
    def getConcentration(self, lon: float, lat: float, elementname: str, normalized: bool = True) -&gt; float:
        &#34;&#34;&#34;
        DESCRIPTION:
        ------------
            Get the surface concentration of an element at the desired coordinate. Units in weight percent (Wt%) -- i.e. a 5% concentration would correspond to a return value of 0.05.
        
        PARAMETERS:
        ------------
            lon : float
                Longitude in range [-180, 180] (lon=0 cuts through Arabia Terra).
            lat : float
                Latitude in range [-90, 90].
            elementname : str
                Element for which you want to make a global concentration map. Options are &#39;cl&#39;, &#39;fe&#39;, &#39;h2o&#39;, &#39;k&#39;, &#39;kvsth&#39;, &#39;si&#39;, and &#39;th&#39;.
            normalized : bool 
                Determine whether or not to normalize to a volatile-free basis. See the next method &#34;getAdjustedConcentration&#34; for details.
            
        RETURN:
        ------------
            float
                Surface concentration of an element at the desired coordinate, using bilinear interpolation if that coordinate is not precisely defined by the data
                    - Units in weight percent (Wt%) -- i.e. a 5% concentration would correspond to a return value of 0.05.
                    - If atleast two of the nearest pixels are unresolved by GRS, just return the nanval.
        &#34;&#34;&#34;

        
        if normalized:
            return self.__getAdjustedConcentration(lon, lat, elementname)
        else:
            clon = utils.lon2clon(lon)
            cola = utils.lat2cola(lat)

            ## get lon/clon/lat/cola lists for easy searching
            
            lons = []
            for i in range(len(self.data[0])):
                lons.append(self.data[0][i][&#34;lon&#34;])
            # print(lons)
            clons = [utils.lon2clon(lon) for lon in lons]
            # print(clons)
            
            lats = []
            for i in range(len(self.data)):
                lats.append(self.data[i][0][&#34;lat&#34;])
            # print(lats)
            colas = [utils.lat2cola(lat) for lat in lats]
            # print(colas)

            ## get indexes and values for four nearest pixels

            if lon &lt;= lons[0] or lon &gt;= lons[-1]: # edge cases
                i_lon_left = len(lons)-1
                i_lon_right = 0
                lon_left = lons[i_lon_left]
                lon_right = lons[i_lon_right]
            else: # everything else
                for i in range(len(lons)):
                    if lon &lt; lons[i]:
                        i_lon_left = i-1
                        i_lon_right = i
                        lon_left = lons[i_lon_left]
                        lon_right = lons[i_lon_right]
                        break

            if lat &lt;= lats[0] or lat &gt;= lats[-1]: # edge cases
                i_lat_bottom = len(lats)-1
                i_lat_top = 0
                lat_bottom = lats[i_lat_bottom]
                lat_top = lats[i_lat_top]
            else: # everything else
                for i in range(len(lats)):
                    if lat &lt; lats[i]:
                        i_lat_bottom = i-1
                        i_lat_top = i
                        lat_bottom = lats[i_lat_bottom]
                        lat_top = lats[i_lat_top]
                        break


            top_left = self.data[i_lat_top][i_lon_left][elementname]
            top_right = self.data[i_lat_top][i_lon_right][elementname]
            bottom_left = self.data[i_lat_bottom][i_lon_left][elementname]
            bottom_right = self.data[i_lat_bottom][i_lon_right][elementname]
            
            
            ## IMPORTANT -- (handling locations where GRS data is undefined) if atleast two of the nearest pixels are unresolved by GRS, just return the nanval. 
            searchable = (top_left, top_right, bottom_left, bottom_right)
            if (searchable.count(self.nanval) &gt; 1):
                return self.nanval

            ## testing

            # print(f&#34;{lat_bottom} {utils.lon2clon(lon_left)} {bottom_left}&#34;)
            # print(f&#34;{lat_bottom} {utils.lon2clon(lon_right)} {bottom_right}&#34;)
            # print(f&#34;{lat_top} {utils.lon2clon(lon_left)} {top_left}&#34;)
            # print(f&#34;{lat_top} {utils.lon2clon(lon_right)} {top_right}&#34;)
            # print()
            # print(lon_left)
            # print(lon_right)
            # print(lat_bottom)
            # print(lat_top)

    #         ## dealing with negative/NaN values
    #         num_reals = 4
    #         avg = 0
    #         if top_left != -1:
    #             num_reals -= 1
    #             avg += top_left
    #         if top_right != -1:
    #             num_reals -= 1
    #             avg += top_right
    #         if bottom_left != -1:
    #             num_reals -= 1
    #             avg += bottom_left
    #         if bottom_right != -1:
    #             num_reals -= 1
    #             avg += bottom_right

    #         avg /= num_reals

            ## bilinear interpolation

            clon_left = utils.lon2clon(lon_left)
            clon_right = utils.lon2clon(lon_right)
            cola_bottom = utils.lat2cola(lat_bottom)
            cola_top = utils.lat2cola(lat_top)


            if abs(i_lon_right - i_lon_left) == 1: # somewhere in the middle
                londist = abs(lon_right-lon_left)
                leftdist = (lon-lon_left) / londist
                rightdist = (lon_right-lon) / londist
            else: # on the edges
                londist = abs(clon_right-clon_left)
                leftdist = (clon-clon_left) / londist
                rightdist = (clon_right-clon) / londist
            # print(londist)
            topinterp = top_left*(1-leftdist) + top_right*(1-rightdist)
            bottominterp = bottom_left*(1-leftdist) + bottom_right*(1-rightdist)


            if abs(i_lat_top - i_lat_bottom) == 1: # somewhere in the middle
                latdist = abs(lat_top-lat_bottom)
                bottomdist = (lat-lat_bottom) / latdist
                topdist = (lat_top-lat) / latdist
            else: # on the edges
                latdist = abs(cola_top-cola_bottom)
                bottomdist = (cola-cola_bottom) / latdist
                topdist = (cola_top-cola) / latdist    
            # print(latdist)

            finalinterp = topinterp*(1-topdist) + bottominterp*(1-bottomdist)

            if elementname == &#34;th&#34;:
                # finalinterp *= 1e-6
                finalinterp *= 10**-6
            else:
                # finalinterp *= 1e-2
                finalinterp *= 10**-2

            return finalinterp

            # return [londist, latdist]
        
        
        
        
        
        
        
    def __getAdjustedConcentration(self, lon: float, lat: float, elementname: str) -&gt; float:
        &#34;&#34;&#34;
        Helper method for &#34;getConcentration&#34; which returns an elemental concentration after normalizing out volatiles at that coordinate.
        
        &#34;Groundwater production from geothermal heating on early Mars and implication for early martian habitability&#34;
            Ojha et al. 2020
            https://www.science.org/doi/10.1126/sciadv.abb1669
            
        &gt; For such measurement to represent the bulk chemistry of the martian upper crust, it must be normalized to 
        &gt; a volatile-free basis (22). That equates to a 7 to 14% increase in the K, Th, and U abundances (22), which 
        &gt; we applied to the chemical maps by renormalizing to Cl, stoichiometric H2O, and S-free basis.
        &#34;&#34;&#34;
        
        init_conc = self.getConcentration(lon, lat, elementname, normalized=False)
        # if elementname == &#34;th&#34;:
        #     init_conc *= 10e-4
        
        sum_volatile_conc = 0
        for volatile in [&#34;cl&#34;, &#34;h2o&#34;, &#34;si&#34;]:
            this_conc = self.getConcentration(lon,lat, volatile, normalized=False)
            
            ## IMPORTANT -- handling locations where GRS data is undefined
            if this_conc == self.nanval:
                return self.nanval
            
            
            
            # print(this_conc)
            if this_conc &gt; 0:
                sum_volatile_conc += this_conc
        # print(sum_volatile_conc)
        # init_conc *= (1)/(1-(sum_volatile_conc/100))
        init_conc *= (1)/(1-(sum_volatile_conc))
        
        return init_conc
    
    
    
    
    
    
    
    
    def getNanVal(self) -&gt; float:
        &#34;&#34;&#34;
        Return value used for coordinates where GRS doesn&#39;t provide data.
        &#34;&#34;&#34;
        return self.nanval</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="GRS.GRS.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="GRS.GRS.gdrive_url"><code class="name">var <span class="ident">gdrive_url</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="GRS.GRS.nanval"><code class="name">var <span class="ident">nanval</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="GRS.GRS.path__datahome"><code class="name">var <span class="ident">path__datahome</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="GRS.GRS.downloadData"><code class="name flex">
<span>def <span class="ident">downloadData</span></span>(<span>self, path__datahome: str, overwrite: bool = False, verbose: bool = False) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">DESCRIPTION:</h2>
<pre><code>Downloads and unzips data to &lt;code&gt;self.path\_\_datahome&lt;/code&gt; if it doesn't already exist there. If it already exists, overwrite if `overwrite==True`, else do nothing.
</code></pre>
<h2 id="parameters">PARAMETERS:</h2>
<pre><code>path : string
    Path from root to the directory within which the GRS data folder either (1) already exists, or (2) will be downloaded.
overwrite : bool
    If true and data folder already exists, delete the data folder and download again. Else skip the download and inform the user. 
verbose : bool
    If true, print contents of unzipped data folder. Else do nothing.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def downloadData(self, path__datahome: str, overwrite: bool = False, verbose: bool = False) -&gt; None:
    &#34;&#34;&#34;
    DESCRIPTION:
    ------------
        Downloads and unzips data to `self.path__datahome` if it doesn&#39;t already exist there. If it already exists, overwrite if `overwrite==True`, else do nothing.
    
    PARAMETERS:
    ------------
        path : string
            Path from root to the directory within which the GRS data folder either (1) already exists, or (2) will be downloaded.
        overwrite : bool
            If true and data folder already exists, delete the data folder and download again. Else skip the download and inform the user. 
        verbose : bool
            If true, print contents of unzipped data folder. Else do nothing. 
    &#34;&#34;&#34;
    
    self.path__datahome = path__datahome
    dd.download_latest(path__datahome=self.path__datahome, data_name=&#39;GRS&#39;, url=self.gdrive_url, overwrite=overwrite, verbose=verbose)
    return</code></pre>
</details>
</dd>
<dt id="GRS.GRS.getConcentration"><code class="name flex">
<span>def <span class="ident">getConcentration</span></span>(<span>self, lon: float, lat: float, elementname: str, normalized: bool = True) -> float</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">DESCRIPTION:</h2>
<pre><code>Get the surface concentration of an element at the desired coordinate. Units in weight percent (Wt%) -- i.e. a 5% concentration would correspond to a return value of 0.05.
</code></pre>
<h2 id="parameters">PARAMETERS:</h2>
<pre><code>lon : float
    Longitude in range [-180, 180] (lon=0 cuts through Arabia Terra).
lat : float
    Latitude in range [-90, 90].
elementname : str
    Element for which you want to make a global concentration map. Options are 'cl', 'fe', 'h2o', 'k', 'kvsth', 'si', and 'th'.
normalized : bool 
    Determine whether or not to normalize to a volatile-free basis. See the next method "getAdjustedConcentration" for details.
</code></pre>
<h2 id="return">RETURN:</h2>
<pre><code>float
    Surface concentration of an element at the desired coordinate, using bilinear interpolation if that coordinate is not precisely defined by the data
        - Units in weight percent (Wt%) -- i.e. a 5% concentration would correspond to a return value of 0.05.
        - If atleast two of the nearest pixels are unresolved by GRS, just return the nanval.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getConcentration(self, lon: float, lat: float, elementname: str, normalized: bool = True) -&gt; float:
    &#34;&#34;&#34;
    DESCRIPTION:
    ------------
        Get the surface concentration of an element at the desired coordinate. Units in weight percent (Wt%) -- i.e. a 5% concentration would correspond to a return value of 0.05.
    
    PARAMETERS:
    ------------
        lon : float
            Longitude in range [-180, 180] (lon=0 cuts through Arabia Terra).
        lat : float
            Latitude in range [-90, 90].
        elementname : str
            Element for which you want to make a global concentration map. Options are &#39;cl&#39;, &#39;fe&#39;, &#39;h2o&#39;, &#39;k&#39;, &#39;kvsth&#39;, &#39;si&#39;, and &#39;th&#39;.
        normalized : bool 
            Determine whether or not to normalize to a volatile-free basis. See the next method &#34;getAdjustedConcentration&#34; for details.
        
    RETURN:
    ------------
        float
            Surface concentration of an element at the desired coordinate, using bilinear interpolation if that coordinate is not precisely defined by the data
                - Units in weight percent (Wt%) -- i.e. a 5% concentration would correspond to a return value of 0.05.
                - If atleast two of the nearest pixels are unresolved by GRS, just return the nanval.
    &#34;&#34;&#34;

    
    if normalized:
        return self.__getAdjustedConcentration(lon, lat, elementname)
    else:
        clon = utils.lon2clon(lon)
        cola = utils.lat2cola(lat)

        ## get lon/clon/lat/cola lists for easy searching
        
        lons = []
        for i in range(len(self.data[0])):
            lons.append(self.data[0][i][&#34;lon&#34;])
        # print(lons)
        clons = [utils.lon2clon(lon) for lon in lons]
        # print(clons)
        
        lats = []
        for i in range(len(self.data)):
            lats.append(self.data[i][0][&#34;lat&#34;])
        # print(lats)
        colas = [utils.lat2cola(lat) for lat in lats]
        # print(colas)

        ## get indexes and values for four nearest pixels

        if lon &lt;= lons[0] or lon &gt;= lons[-1]: # edge cases
            i_lon_left = len(lons)-1
            i_lon_right = 0
            lon_left = lons[i_lon_left]
            lon_right = lons[i_lon_right]
        else: # everything else
            for i in range(len(lons)):
                if lon &lt; lons[i]:
                    i_lon_left = i-1
                    i_lon_right = i
                    lon_left = lons[i_lon_left]
                    lon_right = lons[i_lon_right]
                    break

        if lat &lt;= lats[0] or lat &gt;= lats[-1]: # edge cases
            i_lat_bottom = len(lats)-1
            i_lat_top = 0
            lat_bottom = lats[i_lat_bottom]
            lat_top = lats[i_lat_top]
        else: # everything else
            for i in range(len(lats)):
                if lat &lt; lats[i]:
                    i_lat_bottom = i-1
                    i_lat_top = i
                    lat_bottom = lats[i_lat_bottom]
                    lat_top = lats[i_lat_top]
                    break


        top_left = self.data[i_lat_top][i_lon_left][elementname]
        top_right = self.data[i_lat_top][i_lon_right][elementname]
        bottom_left = self.data[i_lat_bottom][i_lon_left][elementname]
        bottom_right = self.data[i_lat_bottom][i_lon_right][elementname]
        
        
        ## IMPORTANT -- (handling locations where GRS data is undefined) if atleast two of the nearest pixels are unresolved by GRS, just return the nanval. 
        searchable = (top_left, top_right, bottom_left, bottom_right)
        if (searchable.count(self.nanval) &gt; 1):
            return self.nanval

        ## testing

        # print(f&#34;{lat_bottom} {utils.lon2clon(lon_left)} {bottom_left}&#34;)
        # print(f&#34;{lat_bottom} {utils.lon2clon(lon_right)} {bottom_right}&#34;)
        # print(f&#34;{lat_top} {utils.lon2clon(lon_left)} {top_left}&#34;)
        # print(f&#34;{lat_top} {utils.lon2clon(lon_right)} {top_right}&#34;)
        # print()
        # print(lon_left)
        # print(lon_right)
        # print(lat_bottom)
        # print(lat_top)

#         ## dealing with negative/NaN values
#         num_reals = 4
#         avg = 0
#         if top_left != -1:
#             num_reals -= 1
#             avg += top_left
#         if top_right != -1:
#             num_reals -= 1
#             avg += top_right
#         if bottom_left != -1:
#             num_reals -= 1
#             avg += bottom_left
#         if bottom_right != -1:
#             num_reals -= 1
#             avg += bottom_right

#         avg /= num_reals

        ## bilinear interpolation

        clon_left = utils.lon2clon(lon_left)
        clon_right = utils.lon2clon(lon_right)
        cola_bottom = utils.lat2cola(lat_bottom)
        cola_top = utils.lat2cola(lat_top)


        if abs(i_lon_right - i_lon_left) == 1: # somewhere in the middle
            londist = abs(lon_right-lon_left)
            leftdist = (lon-lon_left) / londist
            rightdist = (lon_right-lon) / londist
        else: # on the edges
            londist = abs(clon_right-clon_left)
            leftdist = (clon-clon_left) / londist
            rightdist = (clon_right-clon) / londist
        # print(londist)
        topinterp = top_left*(1-leftdist) + top_right*(1-rightdist)
        bottominterp = bottom_left*(1-leftdist) + bottom_right*(1-rightdist)


        if abs(i_lat_top - i_lat_bottom) == 1: # somewhere in the middle
            latdist = abs(lat_top-lat_bottom)
            bottomdist = (lat-lat_bottom) / latdist
            topdist = (lat_top-lat) / latdist
        else: # on the edges
            latdist = abs(cola_top-cola_bottom)
            bottomdist = (cola-cola_bottom) / latdist
            topdist = (cola_top-cola) / latdist    
        # print(latdist)

        finalinterp = topinterp*(1-topdist) + bottominterp*(1-bottomdist)

        if elementname == &#34;th&#34;:
            # finalinterp *= 1e-6
            finalinterp *= 10**-6
        else:
            # finalinterp *= 1e-2
            finalinterp *= 10**-2

        return finalinterp

        # return [londist, latdist]</code></pre>
</details>
</dd>
<dt id="GRS.GRS.getNanVal"><code class="name flex">
<span>def <span class="ident">getNanVal</span></span>(<span>self) -> float</span>
</code></dt>
<dd>
<div class="desc"><p>Return value used for coordinates where GRS doesn't provide data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getNanVal(self) -&gt; float:
    &#34;&#34;&#34;
    Return value used for coordinates where GRS doesn&#39;t provide data.
    &#34;&#34;&#34;
    return self.nanval</code></pre>
</details>
</dd>
<dt id="GRS.GRS.loadData"><code class="name flex">
<span>def <span class="ident">loadData</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">DESCRIPTION:</h2>
<pre><code>Read GRS data from files into &lt;code&gt;self.data&lt;/code&gt;. Format is a 2-dimensional array, where each entry a dictionary with keys for longitude, colongitude, latitude, colatitude, and concentrations for each of the seven elements.

We use smoothed 5x5 data, but unsmoothed data is available at a higher resolution. Presumably this only requires changing the &lt;code&gt;path\_\_datahome\_data&lt;/code&gt; variable, but this is not tested.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadData(self) -&gt; None:
    &#34;&#34;&#34;
    DESCRIPTION:
    ------------
        Read GRS data from files into `self.data`. Format is a 2-dimensional array, where each entry a dictionary with keys for longitude, colongitude, latitude, colatitude, and concentrations for each of the seven elements.
        
        We use smoothed 5x5 data, but unsmoothed data is available at a higher resolution. Presumably this only requires changing the `path__datahome_data` variable, but this is not tested.
    &#34;&#34;&#34;
    
    
    path__datahome_data = utils.getPath(self.path__datahome, &#39;GRS&#39;, &#39;smoothed&#39;) # os.path.abspath(os.path.join(self.path, &#34;smoothed&#34;))
    
    self.data = []
          
    for datafilename in (os.listdir(path__datahome_data)):            
        if &#34;.tab&#34; in datafilename:
            # print(datafilename)

            # read file
            datafile = open(os.path.abspath(os.path.join(path__datahome_data, datafilename)), &#39;r&#39;)
            rawdata = datafile.readlines()
            datafile.close()

            # populate lon/lat values if first time
            if self.data == []: # populate lon/lat values
                # loop setups
                prevlat = None
                thisline = []
                for rawdataline in rawdata:
                    rawdataline = rawdataline.split()
                    thislat = float(rawdataline[0])
                    thisclon = float(rawdataline[1])
                    thiscola = utils.lat2cola(thislat)
                    thislon = utils.clon2lon(thisclon)
                    # thisconc = rawdataline[2]
                    if thislat != prevlat and prevlat != None:
                        self.data.append(thisline)
                        thisline = []
                    thisline.append({&#34;lon&#34;: thislon, &#34;lat&#34;: thislat, &#34;clon&#34;: thisclon, &#34;cola&#34;: thiscola})
                    prevlat = thislat
                self.data.append(thisline)

            # populate data values                
            elementname = datafilename[:datafilename.index(&#34;_&#34;)]
            counter = 0
            for i in range(len(self.data)):
                for j in range(len(self.data[0])):
                    # rawdataline = rawdataline.split()
                    thisconc = float(rawdata[counter].split()[2])
                    self.data[i][j][elementname] = thisconc if thisconc != 9999.999 else self.nanval
                    counter += 1
                    
    ## adjust longitude (realign to look like my qgis lol)
    lons = []
    for i in range(len(self.data[0])):
        lons.append(self.data[0][i][&#34;lon&#34;])
    # print(lons)
    for i in range(len(lons)):
        if lons[i] &lt; 0:
            break
    for k in range(len(self.data)):
        self.data[k] = self.data[k][i:] + self.data[k][:i]
    return</code></pre>
</details>
</dd>
<dt id="GRS.GRS.visualize"><code class="name flex">
<span>def <span class="ident">visualize</span></span>(<span>self, elementname: str) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">DESCRIPTION:</h2>
<pre><code>Plot the GRS global concentration map for a certain element. For reference, Olympus Mons is on the left.
</code></pre>
<h2 id="parameters">PARAMETERS:</h2>
<pre><code>elementname : str
    Element for which you want to make a global concentration map. Options are 'cl', 'fe', 'h2o', 'k', 'kvsth', 'si', and 'th'.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visualize(self, elementname: str) -&gt; None:
    &#34;&#34;&#34;
    DESCRIPTION:
    ------------
        Plot the GRS global concentration map for a certain element. For reference, Olympus Mons is on the left.
        
    PARAMETERS:
    ------------
        elementname : str
            Element for which you want to make a global concentration map. Options are &#39;cl&#39;, &#39;fe&#39;, &#39;h2o&#39;, &#39;k&#39;, &#39;kvsth&#39;, &#39;si&#39;, and &#39;th&#39;.
    &#34;&#34;&#34;

    test = []
    for i in range(len(self.data)):
        newline = []
        for j in range(len(self.data[0])):
            val = self.data[i][j][elementname]
            newline.append(val if val &lt; 9000 else self.nanval)
            # print
        test.append(newline)
    
    fig, ax = plt.subplots(1,1,figsize=(7,5))
    im = ax.imshow(test[::-1], cmap=&#34;jet&#34;)
    # ax.invert_yaxis()
    cax = fig.add_axes([ax.get_position().x1+0.02,ax.get_position().y0,0.02,ax.get_position().height])
    plt.colorbar(im, cax=cax)
    plt.show()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="GRS.GRS" href="#GRS.GRS">GRS</a></code></h4>
<ul class="two-column">
<li><code><a title="GRS.GRS.data" href="#GRS.GRS.data">data</a></code></li>
<li><code><a title="GRS.GRS.downloadData" href="#GRS.GRS.downloadData">downloadData</a></code></li>
<li><code><a title="GRS.GRS.gdrive_url" href="#GRS.GRS.gdrive_url">gdrive_url</a></code></li>
<li><code><a title="GRS.GRS.getConcentration" href="#GRS.GRS.getConcentration">getConcentration</a></code></li>
<li><code><a title="GRS.GRS.getNanVal" href="#GRS.GRS.getNanVal">getNanVal</a></code></li>
<li><code><a title="GRS.GRS.loadData" href="#GRS.GRS.loadData">loadData</a></code></li>
<li><code><a title="GRS.GRS.nanval" href="#GRS.GRS.nanval">nanval</a></code></li>
<li><code><a title="GRS.GRS.path__datahome" href="#GRS.GRS.path__datahome">path__datahome</a></code></li>
<li><code><a title="GRS.GRS.visualize" href="#GRS.GRS.visualize">visualize</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>