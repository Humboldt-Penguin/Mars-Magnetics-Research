"""
copied from crustal thickness data folder readme

SOURCE:
    Data is generated by the "InSight Crustal Thickness Archive" code by Mark A. Wieczorek: 
        link: https://zenodo.org/record/6477509
        doi: 10.5281/zenodo.6477509
    Code is supplemental to the manuscript:
        Wieczorek, M. A., et al., InSight constraints on the global character of the Martian crust, Journal of Geophysical Research: Planets, 2022.
CODE:
    We use `make-grids.py` with parameters:
        Reference interior model = 0:DWThot
        Seismic thickness at InSight landing site (km) = 30
        rho_north (kg/m3) = 2900
        rho_south (kg/m3) = 2900
        Desired grid spacing in degrees = 0.5 or 0.1 (see file name)
        Grid type = (2) list of (latitude, longitude, value, density)
ALTERATIONS:
    The parameters above give a text file with 4 columns. We load this into a numpy array, remove everything but the third column (actual crustal thickness data), and save a .npy file.


"""


import os
import matplotlib.pyplot as plt
import numpy as np

class Crust:
    
    """
    all private variables:
        dat
        path_src
        spacing
        latrange
        clonrange
        lonrange
        path
    """
    
    crustal_density = 2900 # [kg m^-3]
    # "In Figure 8, we plot the depth of magnetization as a function of crustal thickness. Here we use a crustal thickness model of Wieczorek et al. (2020) which assumes a uniform crustal density of 2,900 kg urn:x-wiley:21699097:media:jgre21714:jgre21714-math-0110 and a minimum crustal thickness of 5 km within the Isidis impact basin."

    
    def __init__(self):
        """Initialize empty Crustal Thickness object (no data yet)."""
        return
    
    
    def loadData(self, path_src, spacing):
        """
        Load crustal thickness data for all elements from data files. 
        
        Data downloaded from data downloader. See `crustal_thickness/README.txt` for more information on data products.
        
        Assumes the following file layout:
            .
            └── src/
                ├── data/
                │   └── crustal_thickness/
                ├── main/
                │   └── main.py
                ├── lib/
                │   ├── GRS.py
                │   └── __init__.py
                └── getdata.sh

        [tree diagram made with tree.nathanfriend.io/]
        """
        
        self.spacing = spacing
        self.path_src = path_src
        self.latrange = np.around(np.arange(90,-90-spacing,-spacing), decimals=3)
        self.clonrange = np.around(np.arange(0,360+spacing,spacing), decimals=3)
        self.lonrange = clon2lon(self.clonrange)
        
        filename_base = 'Mars-thick-DWThot-30-2900__shortened__grid='
        filename = filename_base + str(spacing) + ".npy"
        self.dat = getPath(path_src, 'data', 'crustal_thickness', filename)
        self.dat = np.load(self.dat)

        
        
        
    def checkCoords(self, lon, lat):
        assert (-90 <= lat and lat <= 90), f'ERRROR: latitude {lat} out of bounds.'
        # assert (0 <= clon and clon <= 360), f'ERRROR: colongitude {clon} out of bounds.'
        assert (-180 <= lon and lon <= 180), f'ERRROR: longitude {lon} out of bounds.'
        return
    
    
    def __getExactThickness(self, clon, lat):
        # clon = lon2clon(lon)
        lon = clon2lon(clon)
        self.checkCoords(lon,lat)
        try:
            i_lat = ( np.where(np.abs(self.latrange-lat) < 1e-5) )[0][0]
            i_clon = ( np.where(np.abs(self.clonrange-clon) < 1e-5) )[0][0]
            i = i_lat*self.clonrange.size + i_clon
            return self.dat[i]
        except IndexError:
            raise Exception('ERROR: interpolation is required to crustal thickness at this value -- use `getThickness` instead.')

            
            
            

    def getThickness(self, lon, lat):

        self.checkCoords(lon,lat)    
        clon = lon2clon(lon)


        if clon in self.clonrange and lat in self.latrange: # clon and lat fall perfectly on grid
            finalval = self.__getExactThickness(clon,lat)
            return finalval
        elif clon in self.clonrange and lat not in self.latrange: # perfectly falls on clongitude line, not lat
            # print('e1')
            lattop, latbottom = self.latrange[(np.where(np.abs(self.latrange-lat) < self.spacing))[0]]

            topval = self.__getExactThickness(clon, lattop)
            bottomval = self.__getExactThickness(clon, latbottom)

            # topweight = abs(lat-lattop)/spacing
            # bottomweight = 1-topweight
            bottomweight = abs(lat-lattop)/self.spacing
            topweight = abs(lat-latbottom)/self.spacing

            finalval = topval*topweight + bottomval*bottomweight
            return finalval
        elif clon not in self.clonrange and lat in self.latrange: # perfectly falls on latitude line, not clon
            # print('e2')
            clonleft, clonright = self.clonrange[(np.where(np.abs(self.clonrange-clon) < self.spacing))[0]]
            # lonleft, lonright = clon2lon(clonleft, clonright)

            leftval = self.__getExactThickness(clonleft, lat)
            rightval = self.__getExactThickness(clonright, lat)

            # leftweight = abs(clon-clonleft)/spacing
            # rightweight = abs(clon-clonright)/spacing
            rightweight = abs(clon-clonleft)/self.spacing
            leftweight = abs(clon-clonright)/self.spacing

            finalval = leftval*leftweight + rightval*rightweight
            return finalval        
        else: # falls in the middle of 4 points
            # print('e3')
            lattop, latbottom = self.latrange[(np.where(np.abs(self.latrange-lat) < self.spacing))[0]]
            clonleft, clonright = self.clonrange[(np.where(np.abs(self.clonrange-clon) < self.spacing))[0]]
            # lonleft, lonright = clon2lon(clonleft, clonright)

            topleft = self.__getExactThickness(clonleft, lattop)
            topright = self.__getExactThickness(clonright, lattop)
            bottomleft = self.__getExactThickness(clonleft, latbottom)
            bottomright = self.__getExactThickness(clonright, latbottom)

            # leftweight = abs(clon-clonleft)/spacing
            # rightweight = abs(clon-clonright)/spacing
            rightweight = abs(clon-clonleft)/self.spacing
            leftweight = abs(clon-clonright)/self.spacing

            topinterp = topleft*leftweight + topright*rightweight
            bottominterp = bottomleft*leftweight + bottomright*rightweight

            # topweight = abs(lat-lattop)/spacing
            # bottomweight = 1-topweight
            bottomweight = abs(lat-lattop)/self.spacing
            topweight = abs(lat-latbottom)/self.spacing

            finalval = topinterp*topweight + bottominterp*bottomweight
            return finalval
        
        
        
    def getAvgThickness(self, lon, lat, radius=1):
        
        # lon +/- radius (ie angular)
        
        lons = np.linspace(lon-radius,lon+radius,100)
        lats = np.linspace(lat-radius,lat+radius,100)
        
        total = 0
        
        for i in lons:
            for j in lats:
                total += self.getThickness(i,j)
        return (total / (lons.shape[0] * lats.shape[0]))
        
        
        
    def getDensity(self):
        return self.crustal_density


    

###########################
# General helper functions

def lon2clon(lon):
    return lon % 360
def clon2lon(clon):
    return ((clon-180) % 360) - 180

def lat2cola(lat):
    return lat % 180
def cola2lat(cola):
    return ((cola-90) % 180) - 90





def getPath(*args):
    """Join all arguments into a single path. Use 'current' as a stand in for path to current file."""
    import os
    args = [os.getcwd() if arg == 'current' else arg for arg in args]
    return os.path.abspath(os.path.join(*args))