clc
clear

%%% INPUTS (see decription for more details)
minDiam = 70;
maxDiam = 150;

minAlt = 0;
maxAlt = 200;

padding = 5.0; % eg "0.5" means the shapefiles extend beyond the crater rim by 50% of the radius

crater_database_path = 'C:\Users\zk117\Documents\00.local_WL-202\Mars_Magnetics\geological_features\crater_database\Catalog_Mars_Release_2020_1kmPlus_FullMorphData.csv';

saveLogs = true;

% infile_mavenFolders = 'inputfile_mavenReduced.txt';
% infile_craters = 'craters_70km_to_150km.txt';

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%{ 

- open file and textscan id, lon, lat, diameter
- convert diameter to angular radius (make separate array)

- writemagshape
    - get maven measurements that fit those criteria
    - write to shape file
    

%}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
fullTimer = tic;

% misc prep
    global logs; %#ok<*GVMIS> 
    logs = "";
    verbose(sprintf("Started running at %s \n\n" + ...
                    "* Minimum crater diameter = %.0f \n" + ...
                    "* Maximum crater diameter = %.0f \n" + ...
                    "* Maximum satellite altitude = %.0f \n" + ...
                    "* Crater padding for shapefiles = %.2f", ...
                    datestr(now,'HH:MM'), minDiam, maxDiam, maxAlt, padding));


% read crater locations inputfile into table
    % METHOD 1: read the input file (.txt) generated by generate_crater_locations.m
        % crater = read_crater_file(infile_craters);
    % METHOD 2: start from scratch and call `generate_crater_locations_f.m`, which reads + filters the crater database csv file
        cratersTimer = tic;
        craters = generate_crater_locations_f(crater_database_path, minDiam, maxDiam);
        lon = clon2lon(craters.clon);
        craters = [craters, table(lon)]; clear lon
        verbose(sprintf("\nLoaded crater data in %.2f seconds.", toc(cratersTimer)));


% get angular radius (including padding) of shapefile surround crater
    theta = (diameter2angular( (craters.diam/2) ));
    theta_padded = (diameter2angular( (craters.diam/2) * (1+padding) ));
    craters = [craters, table(theta, theta_padded)];
    clear theta_padded theta



% load all maven data as a table (each line of each maven file) -- DO NOT MODIFY THIS ARRAY
    % METHOD 1: manually loading reduced maven files
%         [mavenFiles,~] = createFiles(getPaths('reducedMaven'), infile_mavenFolders);
%         mvn = load_maven_data(mavenFiles); 
%         clear mavenFiles
    % METHOD 2: loading from matfile
        preload_timer = tic;
        mvnmat = matfile(fullfile(getPaths('matfiles'), 'mvn.mat'));
        mvn = mvnmat.mvn;
        clear mvnmat
        verbose(sprintf("\nLoaded Maven data in %.2f seconds.\n\n", toc(preload_timer)));


% make folders (NOTE: in this folder naming scheme, the number refers to how far the child folder is from the main parent "folder_1"
    folder_1_diamRange = fullfile(getPaths('shapefiles'), ...
                                'craters', ...
                                sprintf('diam=[%.0f,%.0f]_alt=[%.0f,%.0f]', minDiam, maxDiam, minAlt, maxAlt)); 
    [~,~] = mkdir(folder_1_diamRange);


%% making crater shapefiles + plots of B-field cross-section

allCratersTimer = tic;

for i_crater=49 : 49 %height(craters)

    % misc
        thisCraterTimer = tic;

    % If are any tracks that actually pass through the crater (as opposed to being captured in the padded radius), continue with processing
    if maxAlt < 180
        [TEST_clon_rad,~,~,~,~,~,~,~] = MAGcart2sph(...
            mvn.posX,mvn.posY,mvn.posZ,mvn.magX,mvn.magY,mvn.magZ,[],[],[],[],[],[],[],[],[],[craters.clon(i_crater) craters.lat(i_crater) craters.theta(i_crater)]);
    else
        TEST_clon_rad = 'not checking this for optimization purposes';
    end

    if isempty(TEST_clon_rad)
        verbose(sprintf("--- Skipping crater %.0f/%.0f -- no tracks pass through this crater (%.2f sec).", i_crater, length(craters.id), toc(thisCraterTimer)));
    else
        clear TEST_clon_rad
        % Convert position and magnetic field vectors from cartesian to spherical coordinates, and do a spherical cut around a cap specified by [clon lat Th_PADDED]
            [clon_rad,cola_rad,r,data,~,~,~,~] = MAGcart2sph...
                (mvn.posX,mvn.posY,mvn.posZ,mvn.magX,mvn.magY,mvn.magZ,[],[],[],[],[],[],[],[],[],[craters.clon(i_crater) craters.lat(i_crater) craters.theta_padded(i_crater)]);
            
            data = cell2mat(data);
                Blon = data(:,3);
                Bcola = data(:,2);
                Br = data(:,1);
            clear data

        % Extra parameters
            clon_deg = rad2deg(clon_rad); clear clon_rad
            lon_deg = clon2lon(clon_deg); % CHEEKY ADDITION FOR MY SHITTY QGIS
            lat_deg = 90 - rad2deg(cola_rad); clear cola_rad
            
            altitude = r - 3390; clear r

            Bmag = sqrt(Blon.^2 + Bcola.^2 + Br.^2);
            Bmag_norm = Bmag / max(Bmag);

        % Collect variables into table for easy indexing
            thisCrater = table(lon_deg, clon_deg, lat_deg, Bmag, Bmag_norm, Blon, Bcola, Br, altitude);
            clear lon_deg clon_deg lat_deg Bmag Bmag_norm Blon Bcola Br altitude
            
        % Altitude cut
            indices_altCut = thisCrater.altitude < maxAlt;
            thisCrater = thisCrater(indices_altCut,:); clear indices_altCut


        % If there are still measurements within the altitude cut, write to shape file and do cross-sectional analysis
        if height(thisCrater) == 0
            verbose(sprintf("--- Skipping crater %.0f/%.0f -- no tracks fit within the altitude range (%.2f sec).", i_crater, length(craters.id), toc(thisCraterTimer)));
        else % Write to shapefile
            % Make folder
                thisCrater_title = sprintf...
                    (...
                        "%03d__(%.0f,%.0f)__%.0fkm", ...
                        i_crater, ...
                        craters.lon(i_crater), ...
                        craters.lat(i_crater), ...
                        craters.diam(i_crater) ...
                    );
                folder_2_thisCrater = fullfile(folder_1_diamRange, thisCrater_title);
                [~,~] = mkdir(folder_2_thisCrater);

            % Write metadata
                metadata = sprintf...
                    (...
                        "CRATER_ID = %s \n" + ...
                        "LON = %f \n" + ...
                        "CLON = %f \n" + ...
                        "LAT = %f \n" + ...
                        "THETA (crater) = %f \n" + ...
                        "THETA (padded) = %f \n" + ...
                        "DIAMETER = %f \n" + ...
                        "maxAlt = %.0f \n\n" + ...
                        "Shapefile contains %.0f Maven data points \n" + ...
                        "Generated on %s", ...
                        craters.id{i_crater}, ...
                        craters.lon(i_crater), ...
                        craters.clon(i_crater), ...
                        craters.lat(i_crater), ...
                        craters.theta(i_crater), ...
                        craters.theta_padded(i_crater), ...
                        craters.diam(i_crater), ...
                        maxAlt, ...
                        height(thisCrater), ...
                        datestr(now,'mm/dd/yyyy HH:MM') ...
                    );
                writeMetadata(folder_2_thisCrater, metadata);                    

            % Write shapefile
                shape_struct = struct...
                    ( ...
                        'Geometry', 'Multipoint', ...
                        'CRATER_ID', craters.id{i_crater}, ...
                        'Bmag', num2cell(thisCrater.Bmag), ...
                        'Bmag_norm', num2cell(thisCrater.Bmag_norm), ...
                        'Br', num2cell(thisCrater.Br), ...
                        'Blon', num2cell(thisCrater.Blon), ...
                        'Bcola', num2cell(thisCrater.Bcola), ...
                        'Altitude', num2cell(thisCrater.altitude), ...
                        'Lon', num2cell(thisCrater.lon_deg), ...
                        'Clon', num2cell(thisCrater.clon_deg), ...
                        'Lat',num2cell(thisCrater.lat_deg) ...
                    );
                shapewrite(shape_struct, fullfile(folder_2_thisCrater, thisCrater_title));
                verbose(sprintf("- Crater %.0f/%.0f (%s) was processed in %.2f seconds.", i_crater, height(craters), craters.id{i_crater}, toc(thisCraterTimer)));
        end
    end
end

% Final times
    t = seconds(toc(allCratersTimer));
    t.Format = 'hh:mm';
    verbose(sprintf("\n\nFinished generating crater shapfiles in %s (hh:mm).\n", char(t)));
    
    t = seconds(toc(fullTimer));
    t.Format = 'hh:mm';
    verbose(sprintf("Script finished runnning in in %s (hh:mm).", char(t)));

% Save logs as metadata
    writeLogs(folder_1_diamRange, logs, saveLogs);


    
%% separate tracks

clc
tic;

% Find the index where each track begins
    epsilon = 0.10;
    track_indices = 1;
    
    for ptr=1 : height(thisCrater)-1
        if abs(thisCrater.altitude(ptr) - thisCrater.altitude(ptr+1)) > epsilon
            track_indices = [track_indices; ptr+1]; %#ok<AGROW> 
        end
    end
    
    num_tracks = length(track_indices);


% % For each track, put its crater data into cell array
%     tracks = cell(1,num_tracks);
%     for i=1 : num_tracks-1
%         tracks{i} = thisCrater(track_indices(i):track_indices(i+1)-1,:);  
%     end
%     tracks{end} = thisCrater(track_indices(end):end,:);


% (1) Remove tracks that don't pass through the crater, and (2) flag the data points that pass through the crater with an `in_crater` boolean
    good_tracks = {};

    for i=1 : num_tracks
        % Isolate a track's crater-datatable into `thisTrack`
            if i == num_tracks
                endIndex = height(thisCrater);
            else
                endIndex = track_indices(i+1)-1;
            end    
            thisTrack = thisCrater(track_indices(i):endIndex,:);

        % Loop over all points in this track, and if it's within distance
        % `epsilon` of the crater's center, flag the point with the
        % `in_crater` field

            in_crater = false(height(thisTrack),1);
            thisTrack = [thisTrack, table(in_crater)]; clear in_crater %#ok<AGROW> 


            epsilon = craters.theta(i_crater) * 0.9; % tweak scalar as needed

            for pt=1 : height(thisTrack)
                in_lon = abs(craters.lon(i_crater) - thisTrack.lon_deg(pt)) < epsilon;
                in_lat = abs(craters.lat(i_crater) - thisTrack.lat_deg(pt)) < epsilon;
                if in_lon && in_lat
                    thisTrack.in_crater(pt) = true;
                end
            end
        
        % If this track has points that pass through the crater, append to cell
            if ~all(~thisTrack.in_crater)
                good_tracks{end+1} = thisTrack; %#ok<SAGROW> 
            end
    end








hold on
xline(craters.lat(i_crater) - craters.theta(i_crater))
xline(craters.lat(i_crater) + craters.theta(i_crater))




% Count the number of tracks where 

        % NOTE: FIRST DO ANALYSIS WITH BLON, THEN GENERALIZE IT TO A
        % FUNCTION THAT CAN BE CALLED ON COLA, R, AND MAG

    num_minima = 0; num_maxima = 0;

    for i=1 : length(good_tracks)
        % Check if there's a local min/max in the crater, in the range of searchRange*crater_radius beyond the crater rim 
            % [although note that it's not really a scalar of crater_radius, it's really just scaling based on the number of data points that were in the crater for that track]
            searchRange = 0.5;    
            [hasMin, hasMax] = find_num_MinMax(good_tracks{i}.Br, good_tracks{i}, searchRange);

            disp(hasMin);
            disp(hasMax);

            num_minima = num_minima + hasMin;
            num_maxima = num_maxima + hasMax;


        % inspect plots
            scatter(good_tracks{i}.lat_deg(~good_tracks{i}.in_crater), good_tracks{i}.Br(~good_tracks{i}.in_crater), 1, 'b', '.')
            scatter(good_tracks{i}.lat_deg(good_tracks{i}.in_crater), good_tracks{i}.Br(good_tracks{i}.in_crater), 1, 'r', '.')

    end

hold off


% Make plots (3 columns, 2 rows)



% Plot Blon v lon, 
% Bcola v lat, 


% hold on
% xline(craters.lon(i_crater) - craters.theta(i_crater))
% xline(craters.lon(i_crater) + craters.theta(i_crater))
% 
% for i=1 : length(good_tracks)
%     scatter(good_tracks{i}.lon_deg(~good_tracks{i}.in_crater), good_tracks{i}.Blon(~good_tracks{i}.in_crater), 1, 'b', '.')
%     scatter(good_tracks{i}.lon_deg(good_tracks{i}.in_crater), good_tracks{i}.Blon(good_tracks{i}.in_crater), 100, 'r', '.')
% end
% hold off



% hold on
% xline(craters.lat(i_crater) - craters.theta(i_crater))
% xline(craters.lat(i_crater) + craters.theta(i_crater))


% 
% i=1;
% scatter(good_tracks{i}.lat_deg, good_tracks{i}.Bcola, 1, 'b', '.')
% % grad = gradient(good_tracks{i}.Bcola);
% % di = diff(good_tracks{i}.Bcola);
% smooth = smoothdata(good_tracks{i}.Bcola, 'sgolay', 200);
% smoothgrad = gradient(smooth);
% scatter(good_tracks{i}.lat_deg, smooth, 1, 'r', '.')


% for i=1 : length(good_tracks)
%     scatter(good_tracks{i}.lon_deg(~good_tracks{i}.in_crater), good_tracks{i}.Blon(~good_tracks{i}.in_crater), 1, 'b', '.')
%     scatter(good_tracks{i}.lon_deg(good_tracks{i}.in_crater), good_tracks{i}.Blon(good_tracks{i}.in_crater), 100, 'r', '.')
% end
hold off





    
toc;
    
    
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% Functions

%% general use

function [data] = readData(infile, formatSpec)
    [fid,msg] = fopen(infile, 'r');
    assert(fid>=3, msg)
    
    % skip header
    line = "";
    while(~contains(line, "~~~~~START DATA~~~~~"))
        line = fgets(fid);
    end
    
    % read contents
    data = textscan(fid, formatSpec);
    
    fclose(fid);
end


%% Old method of reading crater data
function [crater_data] = read_crater_file(infile_craters)
    crater_data = readData(infile_craters, "%s %f %f %f");
    crater_data = [crater_data{1}, num2cell(crater_data{2}), num2cell(crater_data{3}), num2cell(crater_data{4})];
    crater_data = cell2table(crater_data, ...
        'VariableNames', {'id', 'clon', 'lat', 'diam'});
    lon = table(clon2lon(crater_data.clon), 'VariableNames', {'lon'});
    crater_data = [crater_data, lon];
end



%% Old method of reading maven files

function [mavenFiles,inputFolders] = createFiles(mavenBasePath, infile_mavenFolders)

    file = fopen(infile_mavenFolders,'r');
        inputFolders = textscan(file,'%s');
    fclose(file);
    
    inputFolders = inputFolders{1};
    mavenFiles = [];
    
    for i=1 : length(inputFolders)
        thisFolder = fullfile(mavenBasePath,inputFolders{i}, '*sts');
        this_mavenFiles = dir(thisFolder);
        mavenFiles = [mavenFiles; this_mavenFiles];  %#ok<AGROW> 
    end
    
    return
end


function [mvn_data] = load_maven_data(mavenFiles) %#ok<*DEFNU> 
    %{
        reads the contents of many reduced maven files and returns a table
        containing the posX, posY, posZ, magX, magY, magZ
    %}
    preload_timer = tic;
    mvn_data = [];

%     % unfortunately preallocation does not work with parfor
%         num_measurements = 92825759; % the reduced maven files cumulatively have this many lines
%         mvn_data = zeros(num_measurements,6); % columns will be posX, posY, posZ, magX, magY, magZ

    parfor i_file=1 : length(mavenFiles)
        thisFile = fullfile(mavenFiles(i_file).folder, mavenFiles(i_file).name);
        this_mvn_data = loadpds_reduced_lite(thisFile);
        mvn_data = [mvn_data; this_mvn_data];
%         % unfortunately preallocation does not work with parfor
%             first_line_of_zeros = find(mvn_data(:,6) == zeros(1,6), 1);
%             mvn_data( first_line_of_zeros : first_line_of_zeros+size(this_mvn_data,1)-1 , : ) = this_mvn_data; 
    end

    mvn_data = array2table(mvn_data, ...
        'VariableNames',{'magX', 'magY', 'magZ', 'posX', 'posY', 'posZ'});
    
    verbose(sprintf("\nLoaded Maven data in %.2f seconds.\n", toc(preload_timer)));
end


function [dataArr] = loadpds_reduced_lite(fin)
    %{
        reads the contents of a reduced maven file and returns an array
        where the columsn are [posX, posY, posZ, magX, magY, magZ]
    %}

    [fid,msg] = fopen(fin,'r');
        assert(fid>=3, msg)
        data = textscan(fid, '%*f %*f %*f %*f %*f %*f %*f %f %f %f %*f %f %f %f %*f %*f %*f %*f'); 
    fclose(fid);

    dataArr = cell2mat(data); 
end


%% coordinate/angle conversions

% NOTE: default qgis projection uses lon
function [clon] = lon2clon(lon)  
    clon = mod(lon,360);
end

function [lon] = clon2lon(clon)  
    lon = mod(clon-180,360)-180;
end

function [theta] = diameter2angular(diameter)
    %{
        Converts a crater's diameter from kilometers to degrees. 
        
        This equation is obtained by looking at many craters on JMars and
        roughly measuring the angular separation between the left and right
        edges. We then plot this against diameter in km (accessed from
        generate_crater_locations.m) and then finding the line of best fit,
        which is linear. Rough calculations here:
            https://docs.google.com/spreadsheets/d/1Ylr_Oowq_jV1KNXEGuSvXbWNbPZNGUQF1jjv2eTC7Jg/edit?usp=sharing
    %}

    theta = 0.0186*diameter - 0.122;
end



%% maven track signal analysis

function [hasMin, hasMax] = find_num_MinMax(B_array, thisTrack, searchRange)
    %{
        Check if there's a local min/max in the crater, in the range of
        searchRange*crater_radius beyond the crater rim 
            [although note that it's not really a scalar of crater_radius,
            it's really just scaling based on the number of data points
            that were in the crater for that track]
    %}

    % Smooth data
        B_array = smoothdata(B_array, 'sgolay', 300);
    
    % Find start/end indices of crater and full region where we're searching
        craterStart = find(thisTrack.in_crater, 1, 'first');
        craterEnd = find(thisTrack.in_crater, 1, 'last');

        searchStart = craterStart - round(abs(craterStart-craterEnd)*0.5*searchRange);  
        searchEnd = craterEnd + round(abs(craterStart-craterEnd)*0.5*searchRange);
    
        if searchStart < 0
            searchStart = 0;
        elseif searchEnd > height(thisTrack)
            searchEnd = height(thisTrack);
        end

    % Check if the minimum/maximum values of the full search region are in the crater 
        [~, minIndex] = min(B_array(searchStart:searchEnd));
        minIndex = minIndex + searchStart;
        hasMin = thisTrack.in_crater(minIndex);
    
        [~, maxIndex] = max(B_array(searchStart:searchEnd));
        maxIndex = maxIndex + searchStart;
        hasMax = thisTrack.in_crater(maxIndex);
end


%% logging/metadata functions

function verbose(message)
    %{ 
    - For th sake of debugging, this function provides a centralized place 
    to control how outputs are handled.
    - We save logs as a string then write to a metadata file at the end
    instead of repeatedly opening + partially writing to a file
    %}
    
    global logs;
    message = strcat(message, "\n");
    fprintf(message);
    logs = strcat(logs, message);
end


function writeLogs(folder, logs, saveLogs)
    if saveLogs
        metadata = strcat(sprintf("Generated on %s \n\n------------- \nMATLAB logs: \n------------- \n", datestr(now,'mm/dd/yyyy HH:MM')), logs); %#ok<*UNRCH> 
        writeMetadata(folder, metadata);
    end
end


function writeMetadata(folder, metadata)
    [fid,msg] = fopen(fullfile(folder, 'metadata.txt'),'w');
        assert(fid>=3, msg)
        fprintf(fid, metadata);
    fclose(fid);
end

function writeMetadata_withTitle(folder, metadata, title)
    [fid,msg] = fopen(fullfile(folder, title),'w');
        assert(fid>=3, msg)
        fprintf(fid, metadata);
    fclose(fid);
end


