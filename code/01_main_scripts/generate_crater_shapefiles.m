clc
clear

%%% INPUTS (see decription for more details)
minDiam = 70;
maxDiam = 150;

minAlt = 0;
maxAlt = 200;

padding = 2.0; % eg "0.5" means the shapefiles extend beyond the crater rim by 50% of the radius

crater_database_path = 'C:\Users\zk117\Documents\00.local_WL-202\Mars_Magnetics\geological_features\crater_database\Catalog_Mars_Release_2020_1kmPlus_FullMorphData.csv';

saveLogs = true;

% infile_mavenFolders = 'inputfile_mavenReduced.txt';
% infile_craters = 'craters_70km_to_150km.txt';
% individual_folders = true;
% everything_in_one_folder = true;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%{ 

- open file and textscan id, lon, lat, diameter
- convert diameter to angular radius (make separate array)

- writemagshape
    - get maven measurements that fit those criteria
    - write to shape file
    

%}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
fullTimer = tic;

% misc prep
    global logs; %#ok<*GVMIS> 
    logs = "";
    verbose(sprintf("Started running at %s \n\n" + ...
                    "* Minimum crater diameter = %.0f \n" + ...
                    "* Maximum crater diameter = %.0f \n" + ...
                    "* Maximum satellite altitude = %.0f \n" + ...
                    "* Crater padding for shapefiles = %.2f", ...
                    datestr(now,'HH:MM'), minDiam, maxDiam, maxAlt, padding));

    % verbose(sprintf("Crater input file: %s\n", infile_craters));
    

% stupid old stuff bc i have bad file names and function workings
    % minDiam = str2double(infile_craters(9:strfind(infile_craters,'km_to_')-1));
    % maxDiam = str2double(infile_craters(strfind(infile_craters,'km_to_')+6:strfind(infile_craters,'km.txt')-1)); % lol
    % infile_craters = fullfile(getPaths('repo'), 'code', '03_input_files', 'locations', 'craters', infile_craters); % just to be safe
    % infile_mavenFolders = fullfile(getPaths('repo'), 'code', '03_input_files', 'maven_folders', infile_mavenFolders); % just to be safe


% read crater locations inputfile into table
    % METHOD 1: read the input file (.txt) generated by generate_crater_locations.m
        % crater = read_crater_file(infile_craters);
    % METHOD 2: start from scratch and call `generate_crater_locations_f.m`, which reads + filters the crater database csv file
        cratersTimer = tic;
        craters = generate_crater_locations_f(crater_database_path, minDiam, maxDiam);
        lon = clon2lon(craters.clon);
        craters = [craters, table(lon)]; clear lon
        verbose(sprintf("\nLoaded crater data in %.2f seconds.", toc(cratersTimer)));

% get angular radius (including padding) of shapefile surround crater
    theta = (diameter2angular( (craters.diam/2) ));
    theta_padded = (diameter2angular( (craters.diam/2) * (1+padding) ));
    craters = [craters, table(theta, theta_padded)];
    clear theta_padded theta
    

% load all maven data as a table (each line of each maven file) -- DO NOT MODIFY THIS ARRAY
    % METHOD 1: manually loading reduced maven files
%         [mavenFiles,~] = createFiles(getPaths('reducedMaven'), infile_mavenFolders);
%         mvn = load_maven_data(mavenFiles); 
%         clear mavenFiles
    % METHOD 2: loading from matfile
        preload_timer = tic;
        mvnmat = matfile(fullfile(getPaths('matfiles'), 'mvn.mat'));
        mvn = mvnmat.mvn;
        clear mvnmat
        verbose(sprintf("\nLoaded Maven data in %.2f seconds.\n\n", toc(preload_timer)));


% make folders (NOTE: in this folder naming scheme, the number refers to how far the child folder is from the main parent "folder_1"
    % baseOutputFolder = fullfile(getPaths('shapefiles'), 'craters', sprintf("%0.fkm_to_%0.fkm",minDiam,maxDiam)); 
    folder_1_diamRange = fullfile(getPaths('shapefiles'), ...
                                'craters', ...
                                sprintf('diam=[%.0f,%.0f]_alt=[%.0f,%.0f]', minDiam, maxDiam, minAlt, maxAlt)); 
    [~,~] = mkdir(folder_1_diamRange);
    % folder_2_individual = fullfile(folder_1_kmRange, 'individual');


%% making crater shapefiles + plots of B-field cross-section

allCratersTimer = tic;

for i_crater=1 : 1 %height(craters)

    % misc
        % verbose(sprintf("Now processing crater %s...", craters.id{i_crater}));
        thisCraterTimer = tic;

%     % initialize table for this_crater
%         thisCrater = table();

    % If are any tracks that actually pass through the crater (as opposed to being captured in the padded radius), continue with processing
    if maxAlt < 180
        [TEST_clon_rad,~,~,~,~,~,~,~] = MAGcart2sph(...
            mvn.posX,mvn.posY,mvn.posZ,mvn.magX,mvn.magY,mvn.magZ,[],[],[],[],[],[],[],[],[],[craters.clon(i_crater) craters.lat(i_crater) craters.theta(i_crater)]);
    else
        TEST_clon_rad = 'not checking this for optimization purposes';
    end

    if isempty(TEST_clon_rad)
        verbose(sprintf("--- Skipping crater %.0f/%.0f -- no tracks pass through this crater (%.2f sec).", i_crater, length(craters.id), toc(thisCraterTimer)));
    else
        clear TEST_clon_rad
        % Convert position and magnetic field vectors from cartesian to spherical coordinates, and
        % do a spherical cut around a cap specified by [clon lat Th_PADDED]
            [clon_rad,cola_rad,r,data,~,~,~,~] = MAGcart2sph...
                (mvn.posX,mvn.posY,mvn.posZ,mvn.magX,mvn.magY,mvn.magZ,[],[],[],[],[],[],[],[],[],[craters.clon(i_crater) craters.lat(i_crater) craters.theta_padded(i_crater)]);
            
            data = cell2mat(data);
                Blon = data(:,3);
                Bcola = data(:,2);
                Br = data(:,1);
            clear data

        % Extra parameters
            clon_deg = rad2deg(clon_rad); clear clon_rad
            lon_deg = clon2lon(clon_deg); % CHEEKY ADDITION FOR MY SHITTY QGIS
            lat_deg = 90 - rad2deg(cola_rad); clear cola_rad
            
            altitude = r - 3390; clear r

            Bmag = sqrt(Blon.^2 + Bcola.^2 + Br.^2);
            Bmag_norm = Bmag / max(Bmag);

        % Collect variables into table for easy indexing
            thisCrater = table(lon_deg, clon_deg, lat_deg, Bmag, Bmag_norm, Blon, Bcola, Br, altitude);
            clear lon_deg clon_deg lat_deg Bmag Bmag_norm Blon Bcola Br altitude
            
        % Altitude cut
            indices_altCut = thisCrater.altitude < maxAlt;
            thisCrater = thisCrater(indices_altCut,:); clear indices_altCut


        % If there are still measurements within the altitude cut, write to shape file and do cross-sectional analysis
        if height(thisCrater) == 0
            verbose(sprintf("--- Skipping crater %.0f/%.0f -- no tracks fit within the altitude range (%.2f sec).", i_crater, length(craters.id), toc(thisCraterTimer)));
        else % Write to shapefile
            % Make folder
                thisCrater_title = sprintf...
                    (...
                        "%s__(%.0f,%.0f)__%.0fkm", ...
                        craters.id{i_crater}, ...
                        craters.lon(i_crater), ...
                        craters.lat(i_crater), ...
                        craters.diam(i_crater) ...
                    );
                folder_2_thisCrater = fullfile(folder_1_diamRange, thisCrater_title);
                [~,~] = mkdir(folder_2_thisCrater);

            % Write metadata
                metadata = sprintf...
                    (...
                        "CRATER_ID = %s \n" + ...
                        "LON = %f \n" + ...
                        "CLON = %f \n" + ...
                        "LAT = %f \n" + ...
                        "THETA (crater) = %f \n" + ...
                        "THETA (padded) = %f \n" + ...
                        "DIAMETER = %f \n" + ...
                        "maxAlt = %.0f \n\n" + ...
                        "Shapefile contains %.0f Maven data points \n" + ...
                        "Generated on %s", ...
                        craters.id{i_crater}, ...
                        craters.lon(i_crater), ...
                        craters.clon(i_crater), ...
                        craters.lat(i_crater), ...
                        craters.theta(i_crater), ...
                        craters.theta_padded(i_crater), ...
                        craters.diam(i_crater), ...
                        maxAlt, ...
                        height(thisCrater), ...
                        datestr(now,'mm/dd/yyyy HH:MM') ...
                    );
                writeMetadata(folder_2_thisCrater, metadata);                    

            % Write shapefile
                shape_struct = struct...
                    ( ...
                        'Geometry', 'Multipoint', ...
                        'CRATER_ID', craters.id{i_crater}, ...
                        'Bmag', num2cell(thisCrater.Bmag), ...
                        'Bmag_norm', num2cell(thisCrater.Bmag_norm), ...
                        'Br', num2cell(thisCrater.Br), ...
                        'Blon', num2cell(thisCrater.Blon), ...
                        'Bcola', num2cell(thisCrater.Bcola), ...
                        'Altitude', num2cell(thisCrater.altitude), ...
                        'Lon', num2cell(thisCrater.lon_deg), ...
                        'Clon', num2cell(thisCrater.clon_deg), ...
                        'Lat',num2cell(thisCrater.lat_deg) ...
                    );
                shapewrite(shape_struct, fullfile(folder_2_thisCrater, thisCrater_title));
                verbose(sprintf("- Crater %.0f/%.0f (%s) was processed in %.2f seconds.", i_crater, height(craters), craters.id{i_crater}, toc(thisCraterTimer)));
        end
    end
end

% Final times
    t = seconds(toc(allCratersTimer));
    t.Format = 'hh:mm';
    verbose(sprintf("\n\nFinished generating crater shapfiles in %s (hh:mm).\n", char(t)));
    
    t = seconds(toc(fullTimer));
    t.Format = 'hh:mm';
    verbose(sprintf("Script finished runnning in in %s (hh:mm).", char(t)));

% Save logs as metadata
    if saveLogs
        metadata = strcat(sprintf("Generated on %s \n\n------------- \nMATLAB logs: \n------------- \n", datestr(now,'mm/dd/yyyy HH:MM')), logs); %#ok<*UNRCH> 
        writeMetadata(folder_1_diamRange, metadata);
        % writeMetadata_withTitle(folder_1_kmRange, metadata, sprintf('metadata_%s.txt', datestr(now,'mm-dd-yyyy_HH-MM')));
    end


    
%% separate tracks

% tic;
% jumps = ischange(thisCrater.altitude);
% 
% num_tracks = sum(jumps(:) == 1);
% toc;


clc
tic;

% Find first index of each track
    epsilon = 1;
    track_indices = 1;
    
    for ptr=1 : height(thisCrater)-1
        if abs(thisCrater.altitude(ptr) - thisCrater.altitude(ptr+1)) > epsilon
            track_indices = [track_indices; ptr+1]; %#ok<AGROW> 
        end
    end
    
    num_tracks = length(track_indices);

% % Put crater data for each track in a cell array
%     tracks = cell(1,num_tracks);
%     for i=1 : num_tracks-1
%         tracks{i} = thisCrater(track_indices(i):track_indices(i+1)-1,:);  
%     end
%     tracks{end} = thisCrater(track_indices(end):end,:);


% If a track passes through the crater, put it into a cell array
    tracks = {};

    for i=1 : num_tracks
        % Isolate a track into `thisTrack`
            if i == num_tracks
                endIndex = height(thisCrater);
            else
                endIndex = track_indices(i+1)-1;
            end    
            thisTrack = thisCrater(track_indices(i):endIndex,:);

        % Loop over all points in this track, and if one is within distance `epsilon` of the crater's center, then break
            epsilon = craters.theta(i_crater) * 0.9; % tune scalar by own preference

            in_crater = false;
            for pt=1 : height(thisTrack)
                in_lon = abs(craters.lon(i_crater)-thisTrack.lon_deg(pt)) < epsilon;
                in_lat = abs(craters.lat(i_crater)-thisTrack.lat_deg(pt)) < epsilon;
                if in_lon && in_lat
                    in_crater = true;
                    break
                end
            end

            if in_crater
                tracks{end+1} = thisTrack; %#ok<SAGROW> 
            end
    end




    
toc;
    
    
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% Functions


function [data] = readData(infile, formatSpec)
    [fid,msg] = fopen(infile, 'r');
    assert(fid>=3, msg)
    
    % skip header
    line = "";
    while(~contains(line, "~~~~~START DATA~~~~~"))
        line = fgets(fid);
    end
    
    % read contents
    data = textscan(fid, formatSpec);
    
    fclose(fid);
end

function [crater_data] = read_crater_file(infile_craters)
    crater_data = readData(infile_craters, "%s %f %f %f");
    crater_data = [crater_data{1}, num2cell(crater_data{2}), num2cell(crater_data{3}), num2cell(crater_data{4})];
    crater_data = cell2table(crater_data, ...
        'VariableNames', {'id', 'clon', 'lat', 'diam'});
    lon = table(clon2lon(crater_data.clon), 'VariableNames', {'lon'});
    crater_data = [crater_data, lon];
end


function [theta] = diameter2angular(diameter)
    %{
        Converts a crater's diameter from kilometers to degrees. 
        
        This equation is obtained by looking at many craters on JMars and
        roughly measuring the angular separation between the left and right
        edges. We then plot this against diameter in km (accessed from
        generate_crater_locations.m) and then finding the line of best fit,
        which is linear. Rough calculations here:
            https://docs.google.com/spreadsheets/d/1Ylr_Oowq_jV1KNXEGuSvXbWNbPZNGUQF1jjv2eTC7Jg/edit?usp=sharing
    %}

    theta = 0.0186*diameter - 0.122;
end



function [mavenFiles,inputFolders] = createFiles(mavenBasePath, infile_mavenFolders)

    file = fopen(infile_mavenFolders,'r');
        inputFolders = textscan(file,'%s');
    fclose(file);
    
    inputFolders = inputFolders{1};
    mavenFiles = [];
    
    for i=1 : length(inputFolders)
        thisFolder = fullfile(mavenBasePath,inputFolders{i}, '*sts');
        this_mavenFiles = dir(thisFolder);
        mavenFiles = [mavenFiles; this_mavenFiles];  %#ok<AGROW> 
    end
    
    return
end


function writeMetadata(folder, metadata)
    [fid,msg] = fopen(fullfile(folder, 'metadata.txt'),'w');
        assert(fid>=3, msg)
        fprintf(fid, metadata);
    fclose(fid);
end

function writeMetadata_withTitle(folder, metadata, title)
    [fid,msg] = fopen(fullfile(folder, title),'w');
        assert(fid>=3, msg)
        fprintf(fid, metadata);
    fclose(fid);
end

function [mvn_data] = load_maven_data(mavenFiles) %#ok<*DEFNU> 
    %{
        reads the contents of many reduced maven files and returns a table
        containing the posX, posY, posZ, magX, magY, magZ
    %}
    preload_timer = tic;
    mvn_data = [];

%     % unfortunately preallocation does not work with parfor
%         num_measurements = 92825759; % the reduced maven files cumulatively have this many lines
%         mvn_data = zeros(num_measurements,6); % columns will be posX, posY, posZ, magX, magY, magZ

    parfor i_file=1 : length(mavenFiles)
        thisFile = fullfile(mavenFiles(i_file).folder, mavenFiles(i_file).name);
        this_mvn_data = loadpds_reduced_lite(thisFile);
        mvn_data = [mvn_data; this_mvn_data];
%         % unfortunately preallocation does not work with parfor
%             first_line_of_zeros = find(mvn_data(:,6) == zeros(1,6), 1);
%             mvn_data( first_line_of_zeros : first_line_of_zeros+size(this_mvn_data,1)-1 , : ) = this_mvn_data; 
    end

    mvn_data = array2table(mvn_data, ...
        'VariableNames',{'magX', 'magY', 'magZ', 'posX', 'posY', 'posZ'});
    
    verbose(sprintf("\nLoaded Maven data in %.2f seconds.\n", toc(preload_timer)));
end


function [dataArr] = loadpds_reduced_lite(fin)
    %{
        reads the contents of a reduced maven file and returns an array
        where the columsn are [posX, posY, posZ, magX, magY, magZ]
    %}

    [fid,msg] = fopen(fin,'r');
        assert(fid>=3, msg)
        data = textscan(fid, '%*f %*f %*f %*f %*f %*f %*f %f %f %f %*f %f %f %f %*f %*f %*f %*f'); 
    fclose(fid);

    dataArr = cell2mat(data); 
end


% NOTE: default qgis projection uses lon
function [clon] = lon2clon(lon)  
    clon = mod(lon,360);
end
function [lon] = clon2lon(clon)  
    lon = mod(clon-180,360)-180;
end



function verbose(message)
    %{ 
    - For th sake of debugging, this function provides a centralized place 
    to control how outputs are handled.
    - We save logs as a string then write to a metadata file at the end
    instead of repeatedly opening + partially writing to a file
    %}
    
global logs;
    message = strcat(message, "\n");
    fprintf(message);
    logs = strcat(logs, message);
end



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Self-notes:
